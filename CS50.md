# CS50 Lecture from Eduwith (NAVER)

## Algorithm

0. Big-O (Complexity), Omega (Ω)

Big-O : Worst case to find
Ω : Best case to find
Θ : Same O,Ω Case

```
O(n^2)      : Bubble sort, Selection Sort
O(n log n)  : Merge Sort
O(n)        : Linear Search
O(log n)    : Binary Search
O(1)

Ω(n^2)      : (Bubble sort), Selection Sort
Ω(n log n)  : Merge Sort
Ω(n)        : Bubble sort
Ω(log n)    :
Ω(1)        : Linear Search, Binary Search

Θ(n^2)      : Selection sort
Θ(n log n)  : Merge sort
Θ(n)        :
Θ(log n)    :
Θ(1)        :
```

1. 1. Linear Search { O(n), Ω(1) }

```
차례대로 찾는거.

   ex1)
        for ( i = 0; i < length of Array; i++)
        {
            if ~~
            else ~~
        }
```

1. 2. Binary Search { O(log n), Ω(1) }

```
2갈래로 계속해서 나눠서 찾는법.

ex1)
    1 ~ 100 중 숫자 하나 찾는다면,
    50 확인
    -> UP/DOWN ?
    -> 25확인 or 75 확인
    -> UP/DOWN ?
    이런식
```

2.1. Bubble Sort { O(n^2), Ω(n) }

```
(거품이 떠오르듯)
왼쪽에서 오른쪽으로,
왼쪽에서 오른쪽으로
하나씩 비교해서 옮겨감
```

2.2. Selection Sort ( O(n^2), Ω(n^2) )

```
가장 작은수를 찾아서, 0번째로,
그담 작은수를 찾아서, 1번째로,
 - 반복 -
```

2.3.1. Recursion

```
함수가 계속해서 스스로(함수)를 call함
Ex) by C

#include <cs50.h>
#include <stdio.h>

void draw(int h);

int main(void)
{
    int height = get_int("Height: ");

    draw(height);
}
<!--! Recursion Function -->
void draw(int h)
{
    <!--* Error Check -->
    if(h == 0)
    {
        return;
    }
    <!--* Recursio Call -->
    draw(h-1);

    <!--* Function Part-->
    for (int i = 0; i <h; i++)
    {
        printf("#");

    }
    printf("\n");

}


```

2.3. Merge Sort {O(n log n), Ω(n log n)}

```
Left sort
Right sort
Merge


```
